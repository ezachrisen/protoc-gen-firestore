package module

const serviceTpl = `
// Code generated by protoc-{{name}}. DO NOT EDIT.
// versions:
// source: {{ .InputPath }} 

package {{ package . }} 

import (
 "fmt"
 "context"
 "cloud.google.com/go/firestore"
 // "github.com/golang/protobuf/ptypes"
 // "google.golang.org/genproto/protobuf/field_mask"
 //  "google.golang.org/api/iterator"
 //	"google.golang.org/grpc/codes"
	"github.com/golang/protobuf/ptypes/empty"
	"google.golang.org/grpc/status"
	"github.com/ezachrisen/gcplog"

)

var (
// Ensure we have no unused imports
  _ = status.Errorf(status.Code(fmt.Errorf("dummy %s","dummy")), "dummy")
  _ = gcplog.GrpcStatus
  _ = firestore.Delete
  _ = context.Canceled
  _ = empty.Empty{}
)


{{/*

Generate a struct type for all services with method implementations. 
For "standard" methods of the form {Get,Create,Delete,Update,List}Entity, 
the generated service methods will read/write to Firestore using the generated
Firestore clients. All other methods will return an error. 

*/}}


{{range .Services }} 
    {{if shouldGenerateService . }} 

		{{ $service_name := .Name }}

		type {{.Name}} struct {
		   client *firestore.Client
		   collection string 
		}


		func New{{.Name}}(c *firestore.Client, collection string) (*{{.Name}}, error) {
		  if c == nil {
			return nil, fmt.Errorf("initializing {{.Name}}: missing firestore client")
		  }

		  if collection == "" { 
			return nil, fmt.Errorf("initializing {{.Name}}: missing collection name")

		  }

			return &{{.Name}} {
			   client: c,
			   collection: collection, 
			}, nil 

		}


		{{range .Methods}}
		{{ $output := .Output.Name}}
		{{ if eq $output "Empty" }}
		   {{ $output = "empty.Empty" }}
		{{ end }} 

		func (s *{{$service_name}}) {{.Name}}(ctx context.Context, req *{{.Input.Name}}) (*{{$output}}, error)  {


			   {{/* if this is a standard method (Get,Create, etc.) generate methods calling the firestore client */}}
			   {{if isEntityMethod .}}
					 {{ $verbEntity := getVerbEntity . }}                

					 {{ if eq $verbEntity.Verb "Create" }} 
						  err := Create{{.Input.Name}}(ctx, s.c, s.collection, req)
						  if err != nil {
							  err = status.Errorf(status.Code(err), "{{.Name}}: error saving {{.Input.Name}} '%s': %v",
												  req.Name, err)
							  gcplog.GrpcInfo(ctx, err)
							  return nil, err
						  }
						  return req, nil


					 {{ else if eq $verbEntity.Verb "Get" }} 

						  doc, err := Get{{.Output.Name}}(ctx, s.client, s.collection, req.Name)
						  if err != nil {
							  err = status.Errorf(status.Code(err), "Get{{.Output.Name}}: '%s': %v", req.Name, err)
							  gcplog.GrpcInfo(ctx, err)
							  return nil, err
						  }
						  return doc, nil


					 {{ else if eq $verbEntity.Verb "Delete" }} 

						  err := Delete{{$verbEntity.Entity}}(ctx, s.client, s.collection, req.Name)
						  if err != nil {
							  err = status.Errorf(status.Code(err), "Delete{{$verbEntity.Entity}}: '%s': %v", 
												  req.Name, err)
							  gcplog.GrpcInfo(ctx, err)
							  return nil, err
						  }
						  return &empty.Empty{}, nil


					 {{ else if eq $verbEntity.Verb "Update" }} 

						  err := Update{{$verbEntity.Entity}}(ctx, s.client, s.collection, req)
						  if err != nil {
							  err = status.Errorf(status.Code(err), "Update{{$verbEntity.Entity}}: '%s': %v", 
												 req.Name, err)
							 gcplog.GrpcInfo(ctx, err)
							 return nil, err
						 }
						 return req.{{$verbEntity.Entity}}, nil

					 {{ else if eq $verbEntity.Verb "List" }} 

						  l, err := List{{$verbEntity.Entity}}s(ctx, s.client, s.collection, req)
						  if err != nil {
							  err = status.Errorf(status.Code(err), "List{{$verbEntity.Entity}}s: '%s': %v", 
												 req.Name, err)
							 gcplog.GrpcInfo(ctx, err)
							 return nil, err
						 }
						 return &l, nil

					 {{ end }}  {{/* end if create */}}


			   {{ else }} {{/* if this is not a "standard" method, return unimplemented error message */}}

				  return nil, fmt.Errorf("{{.Name}} is not implemented")

			   {{ end }}  {{/* end if entity method */}} 
		}
		{{end}} {{/* end range methods */}}
 
    {{end}} {{/* should generate service */}}

{{end}}  {{/* end range services  */}}


`
